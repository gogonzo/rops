% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/set_union.R
\docType{methods}
\name{set_union}
\alias{set_union}
\alias{set_union,ANY,ANY-method}
\alias{set_union,atomic,atomic-method}
\alias{set_union,list,list-method}
\title{Recursive \code{union} for lists}
\usage{
set_union(x, y, .expr = if (FALSE) return(x), .depth = 0L, .name = NULL)

\S4method{set_union}{ANY,ANY}(x, y, .expr = if (FALSE) return(x), .depth = 0L, .name = NULL)

\S4method{set_union}{atomic,atomic}(x, y, .expr = if (FALSE) return(x), .depth = 0L, .name = NULL)

\S4method{set_union}{list,list}(x, y, .expr = if (FALSE) return(x), .depth = 0L, .name = NULL)
}
\arguments{
\item{x}{(\code{list}, \code{atomic}) object to compare.}

\item{y}{(\code{list}, \code{atomic}) obejct to compare with.}

\item{.expr}{(\code{language}) any syntactically valid R expression.
Argument is parsed, evaluated and passed recursivelly to calls run on the nested
elements of \code{x} and \code{y}. Other arguments (\code{.name}, \code{.depth} and \code{.type}) can be used
to influence output of the comparisons.
For example \code{if (.depth == 2) return(x)} will return \code{x} for the nested list elements
of depth equal \code{2}.
Note: If \code{.expr} has a \code{return} statement please be aware that it should be the
same as the type of the output.}

\item{.depth}{(\code{integer(1)}) Private argument, please don't specify.
depth of the call. Increases by \code{1} according to depth of the lists \code{x} and \code{y}}

\item{.name}{(\code{character(1)}) Private argument, please don't specify.
Used to identify the name of the current list element when calld resursivelly.
\code{.name} can be used with \code{.expr}.}
}
\value{
object of the same class as \code{x} or NULL if doesn't differ from \code{y}.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}\cr
Gets recursive \code{union} for lists.
}
\examples{
set_union(c(1, 2), c(2, 3))
set_union(list(a = 1, b = 2), list(b = 2, c = 3))
set_union(letters[1:2], letters[2:3])
}
